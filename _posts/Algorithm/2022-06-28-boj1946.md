---
title:  "BOJ 1946 with js _ 신입 사원 (Greedy)"
excerpt: "BOJ 1946"
toc: true
toc_sticky: true

categories:
  - 백준 알고리즘
tags:
  - [Algorithm, Coding Test, JS, Java Script, Baekjoon]
---  

## 1946 with Node.js _ 신입 사원 ##

## 문제 ## 
언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.

그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.

이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.

## 입력 ## 
> 첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 
> 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 
> 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 
> 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.

## 출력 ##
> 각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.

## 정답 코드 ##

```js
const fs = require("fs");
const stdin = (
  process.platform === "linux"
    ? fs.readFileSync("/dev/stdin").toString()
    : `` // 기본 입력값 설정 (백준 코딩테스트에서 비워놔도 무방하다.)
).split("\n");

const input = (() => {  //input()을 호출할 때마다 한줄씩 읽어온다.
  let line = 0;
  return () => stdin[line++];
})(); 

const count = +input();
for(let i = 0; i < count; i++ ){
    let result = 0;
    const peopleCount = +input();
    const peopleRanks = [];
    for(let j = 0; j < peopleCount; j++){
        const rank = input().split(' ').map(value => Number(value));
        peopleRanks.push(rank);
    }
    
    peopleRanks.sort((a,b) => a[0]-b[0]); // 서류 순으로 정렬
  
    let secondRanks = peopleCount + 1; // 기준 면접 순서 초기 값은 가장 낮은 면접 순서보다 하나 더 낮게 설정
    for(let j = 0; j < peopleRanks.length; j++){
        if(peopleRanks[j][1] < secondRanks){ // 서류 순서가 낮은 순으로 기준이 되는 면접 순보다 높은지 판단
            secondRanks = peopleRanks[j][1]; // 가장 높은 면접 순서를 기준으로 다시 설정
            result++; // 결과 값 추가
        }
    }
    
    console.log(result);
}
```

## 살펴보아야 할 점 ##
서류를 순서대로 먼저 정렬하여 항상 이전 값보다 서류 순서가 낮도록 설정하였다. 그래서 각각의 해를 비교하여 최적값을 구하는 Greedy방식이 결과값을 도출할 수 있었다.

### DP ###
동적 계획법의 원리는 매우 간단하다. 일반적으로 주어진 문제를 풀기 위해서, <b>문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 것이다.</b> 각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다. 이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다. 특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.동적 계획 알고리즘은 최단 경로 문제, 행렬의 제곱 문제 등의 최적화에 사용된다. 이것은 동적 계획법은 문제를 해결하기 위한 모든 방법을 검토하고, 그 중에 최적의 풀이법을 찾아내기 때문이다. 이에 우리는 동적 계획법을 모든 방법을 일일이 검토하여 그 중 최적해를 찾아내는 주먹구구식 방법이라고 생각할 수 있다. 그러나 문제가 가능한 모든 방법을 충분히 빠른 속도로 처리할 수 있는 경우, 동적 계획법은 최적의 해법이라고 말할 수 있다.때로는 단순한 재귀함수에 저장 수열(이전의 데이터를 모두 입력하는 수열)을 대입하는 것 만으로도 최적해를 구할 수 있는 동적 알고리즘을 찾을 수 있다. 그러나 대다수의 문제는 이보다 훨씬 더 복잡한 프로그래밍을 요구한다. 그 중에 일부는 여러 개의 매개 변수를 이용하여 재귀 함수를 작성해야 하는 것도 있고, 아예 이러한 방법으로 동적 알고리즘을 짤 수 없는 문제 또한 존재한다. 이러한 퍼즐로는 대표적으로 Egg Dropping Puzzle이 있다.

### 그리디 알고리즘 ###
동적 계획법은 위에서 설명했듯이, 주먹구구식의 방법이라는 단점이 있다. 이러한 단점을 극복하기 위하여, 동적 계획법 대신 그리디 알고리즘 이 등장했다. 그리디 알고리즘은 항상 최적해를 구해주지는 않지만, 다행히 MST(최소 비용 나무 문제) 등의 여러 문제에서 그리디 알고리즘이 최적해를 구할 수 있음이 이미 입증되었다. 그리디 알고리즘과 동적 계획법을 비교하자. 우리가 차량 정체 구간에서 A라는 지점에서 B라는 지점까지 가능한 빨리 이동하는 경로를 찾고 싶다고 하자. 이 문제에서 동적 계획법을 사용한다면, 우리가 갈 수 있는 모든 상황과 교통 정체를 전부 감안하여 최적의 경로를 찾아낸다. 반면 그리디 알고리즘은 전체적인 상황을 고려하지 않고, 순간순간 교차로가 보일 때마다 가장 빠른 경로를 검색하여 찾아줄 것이다.물론 동적 계획법으로 경로를 검색하는 동안 우리가 운전을 잠깐 쉬어야 하듯이, 우리는 동적 계획법을 사용하면 약간의 시간이 걸린다는 단점이 있다. 그러나 이렇게 얻어낸 경로는 (교통 환경이 변하지 않았다는 가정 하에) 우리가 갈 수 있는 가장 빠른 길이 된다고 장담할 수 있다. 반면 그리디 알고리즘은 즉효성이 있는 대신, 항상 최적의 경로를 찾아주지는 않는다. <b>각 구간마다 최적의 경로를 찾는다고 해도 그것이 전체적으로 최적의 경로가 되지는 않기 때문이다.</b> 즉, 동적 계획법은 그리디 알고리즘에 비해 시간적으로는 효율적이지 못할 수는 있어도, 그 결과에 대해서는 효율적인 값을 구할 수가 있다.

### 참고사이트 ###
<a href="https://kwanghyuk.tistory.com/4" target="_blank">https://kwanghyuk.tistory.com/4</a>

### 문제 링크 ### 
<a href="https://www.acmicpc.net/problem/1946" target="_blank">https://www.acmicpc.net/problem/1946 </a>