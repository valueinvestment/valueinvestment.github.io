---
title:  "네트워크 원리 chapter 2 - 5, 6"
excerpt: "데이터를 송 수신한다"
toc: true
toc_sticky: true

categories:
  - 네트워크 원리
tags:
  - [Network]
---  

# 5. IP와 이더넷의 패킷 송수신 동작 #
TCP 담당 부분에서 필요한 헤더 및 데이터를 추가한 이후에 IP 담당 부분에게 의뢰한다.

## 1. 패킷의 기본 ##
- 패킷은 헤더 + 데이터로 나뉜다. (주소 등의 제어 정보 + 안의 내용물)

![패킷의 구조](https://user-images.githubusercontent.com/63405904/138543891-a6fa10df-b371-4f35-97a5-7c2001b22910.png){: #magnific title="https://yjksw.github.io/one-percent-network-4/"}

- 패킷의 흐름은 패킷의 헤더에 적힌 제어정보와 중계 장치에 있는 표의 정보를 결합하여 다음 패킷 목적지로 이동하며 최종 목적지에 도착한다.
  - 송신처와 최송 수신처를 ‘엔드 노드’라고 부른다.

### TCP/IP 에서 패킷 구조 ###
두 가지 중계 장치가 있다. 서브넷을 관리하는 ‘허브’와 IP를 담당하는 ‘라우터’이다.

각각 다음 역할을 한다.

- 라우터가 목적지를 확인하여 다음 라우터를 찾는다.
  - IP가 다음 목적지를 확인하여 다음 IP 중계 장치를 찾는다.
- 허브가 서브넷 안에서 패킷을 운반해 다음 라우터에 도착하도록 한다.
  - 서브넷 안의 이더넷이 라우터까지 패킷을 운반한다.

위 역할을 수행하기 위해서 패킷에 다음 두 헤더가 붙어 있다.

1. MAC 헤더 (이더넷용 헤더)
2. IP 헤더 (IP용 헤더)

- 패킷 운반 흐름은 다음과 같다.
  - 먼저 클라이언트가 TCP 헤더 + 데이터를 이어붙이고 목적 IP 주소에 맞는 다음 라우터를 조사한다.
  - 다음 라우터가 정해지면 해당 라우터에 대한 MAC 주소를 조사하고 패킷의 MAC 헤더에 추가한다.
  - 이더넷에게 해당 라우터로 패킷을 전송하도록 의뢰하여 패킷을 송신한다.
  - 이더넷에 의해 허브에 도착한다. 허브에서 이더넷 표와 헤더 정보를 결합해서 다음 라우터로 중계한다.
    - 만일 허브가 여러개라면 여러 허브를 순차적으로 경우한다.
  - 다음 라우터에 도착해서 IP용 표를 통해 다음 라우터를 조사하여 MAC 주소를 헤더가 기록한다.
    - 동일하게 허브를 경유하여 다음 라우터에 도착한다. 수신처에 도착할 때까지 반복한다.

![패킷의 운반 원리](https://user-images.githubusercontent.com/63405904/138543896-57e300fe-ae57-4d72-9638-387b2acdd4cd.png){: #magnific title="https://yjksw.github.io/one-percent-network-4/"}

- 이더넷 대신 무선 LAN, ADSL 등으로 대체될 수 있다.
  - IP의 의뢰를 받아서 패킷을 운반할 수 있는 것이면 된다.

## 2. 패킷 송수신 동작의 개요 ##

IP 담당은 패킷을 송출하고 실제 패킷의 운반은 네트워크 기기인 허브 및 라우터가 수행한다.

- TCP 담당에서 TCP 헤더와 데이터가 붙은 채로 IP 담당에게 넘어온다.
- IP 담당은 넘어온 패킷을 들여다보지 않고 단지 헤더를 추가한다.
  - IP 헤더와 MAC 헤더를 추가한다.
- IP 헤더: 목적지를 나타내는 제어정보
- MAC 헤더: LAN을 사용해서 가까운 라우터까지 패킷을 운반할 때 사용할 제어정보
- 완성된 패킷을 네트워크 하드웨어 LAN 어댑터에 보낸다.
  - 0과 1로 이루어진 디지털 데이터의 모습이다.
  - LAN 어댑터는 전기나 빛의 신호로 바꾸어 케이블로 송출한다.
  - 이후 허브나 라우터 등의 중계 장치에 도착한다.
- IP 담당에서 바라보는 패킷은 그 역할이 구분되어 있지 않고 단순히 ‘패킷’이라는 덩어리일 뿐이다. 패킷의 내용, 순서, 유무도 상관하지 않는다.
 
## 3. 수신처 IP주소를 기록한 IP 헤더를 만든다 ##

- IP 담당 부분은 TCP 담당 부분에서 패킷 송∙수신 의뢰를 받으면 IP 헤더를 만들어 TCP 헤더의 앞에 붙인다. <b>IP 헤더에서 가장 중요한 것은 수신처 IP와 송신처 IP</b>이다. 

- 수신처 IP 주소는 애플리케이션->TCP 담당부분->IP로 전달받은 주소이며, IP는 패킷을 송신할 책임만 가지므로 IP주소가 잘못된 경우 애플리케이션측에 책임이 있는 것으로 간주한다.

- 송신용 IP주소는 LAN 어댑터당 하나씩 할당되므로 LAN 어댑터가 여러개일 경우 하나를 선택해야한다.

![IP Header](https://jayyhkwon.github.io/assets/post-img/network/ipHeader.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

![IP Header2](https://user-images.githubusercontent.com/46305139/96710908-add13f00-13d7-11eb-8542-cffe469a32f1.jpg){: #magnific title="https://github.com/Road-of-CODEr/one-percent-network/blob/master/20201021/Chapter2-2.md"}

- IP 경로표, 라우팅 테이블

![IP Header](https://jayyhkwon.github.io/assets/post-img/network/rootTable.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}
- 어느 LAN 어댑터에서 보내는지 정하고 해당 IP 주소를 송신처 IP 주소로 설정한다.

- Network Destination : 수신처 IP 주소와 비교하여 어느 행에 해당하는지 찾아낸다
- Interface : LAN 어댑터 등의 네트워크용 인터페이스를 나타내고, 인터페이스에서 패킷을 송신하면 상대에 패킷을 전해줄 수 있다는 의미이다.
- Gateway : 다음 라우터의 IP 주소, 여기에 적힌 주소로 건네면 목적지에 패킷을 중계해준다는 것을 나타낸다.

- 만약 라우터를 나타내는 ‘Gateway’ 항목과 ‘Interface’ 항목의 IP 주소가 같으면 라우터로 중계하지 않고 상대에게 직접 패킷을 전할 수 있는 것이 된다.

## 4. 이더넷용 MAC 헤더를 만든다 ##

- IP 헤더를 만들었으면 IP 담당 부분 앞에 MAC 헤더를 붙인다. 이더넷의 수신처 판단구조로 사용하는 것이 MAC 헤더이다.
  - IP 헤더의 수신처 IP 주소에 패킷을 전달하는 목적지가 쓰여져 있으므로 이것을 보고 어디로 운반해야 하는지를 판단할 수 있지만, 이더넷에는 TCP/IP 개념이 통용되지 않는다. 따라서 이더넷은 TCP/IP와 다른 구조로 패킷의 수신처를 판단하며, 이 구조를 따르지 않으면 이더넷 패킷을 운반할 수가 없다.

![MAC Header](https://jayyhkwon.github.io/assets/post-img/network/macHeader.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

- MAC 헤더 구성요소
  - 수신처 MAC 주소
    - 패킷을 최종 건네줄 대상을 아직 파악하지 못했기 때문에 IP경로표에서 찾은 ‘Gateway’ 항목에 기록되어 있는 IP주소의 기기가 패킷을 건네줄 상대가 된다
  - 송신처 MAC 주소
    - LAN 어댑터의 ROM에서 읽어오나, LAN 어댑터가 여러 개 일경우 하나를 선택해야 한다.
  - 이더 타입(Ether Type)
    - 사용하는 프로토콜의 종류를 나타낸다. TCP/IP=(0800)
    - 이더넷의 내용물은 IP 나 ARP 라는 프로토콜의 소켓이며, 규칙에 따라 값을 기록하게 된다.

## 5. ARP로 수신처 라우터의 MAC 주소를 조사한다 ##

![Get MAC header by ARP](https://jayyhkwon.github.io/assets/post-img/network/arp.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

### ARP(Address Resolution Protocol) ###
- 이더넷은 연결되어 있는 전체에게 패킷을 전달하는 브로드캐스트라는 구조가 있는데, 이 구조를 이용하여 특정 IP를 가진 기기가 있는지 전원에게 요청을 보낸다. (모두에게 질의하고 해당 대상만 응답한다).

- 라우팅 테이블이 올바르다면 응답이 돌아오지만, 그렇지 않다면 상대가 없는 것으로 되어 송신 동작이 실패한다.

- ARP cache
  - 패킷을 보낼 때마다 이 동작을 하면 ARP 패킷이 불어나기 때문에 한 번 조사한 결과는 ARP 캐시라는 메모리 영역에 보존하여 다시 이용한다.
  - ARP 캐시가 언제까지나 실제 주소와 같을 거라는 보장은 없기 때문에, ARP 캐시는 일정 시간이 지나면 삭제하게 되어 있다. OS 종류마다 다르지만 보통 몇 분 정도이다.

이 MAC 헤더를 IP 헤더 앞에 붙이면 패킷이 완성된다. 이 패킷을 만들기까지가 IP 담당부분의 역할이다. LAN 어댑터는 완성된 패킷을 송신하기만 하면 된다.

## 6. 이더넷의 기본 ##

### 이더넷 ###

- 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술 (현재는 스위칭 허브를 이용해 원하는 상대에게만 신호가 흐름.)
- MAC 헤더의 수신처 MAC 주소에 기억된 상대에게 패킷을 전달하고, 송신처 MAC 주소로 송신처를 나타낸 후 이더타입으로 패킷의 내용물을 나타낸다
- 패킷의 내용물은 보지 않는다. 이더넷의 송수신 동작은 TCP 동작 단계에 상관 없이 모든 것에 공통이다

![이더넷 종류](https://jayyhkwon.github.io/assets/post-img/network/ethernet.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}


## 7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다 ##
- 메모리에 저장되어 있는 데이터는 그대로 상대에게 보낼 수 있는 게 아니다. 따라서 전기나 빛의 신호로 변환하여 케이블에 송출하는데, 이것이 송수신의 본질이다.

LAN 어댑터
- LAN 드라이버 소프트웨어를 통해 송수신을 담당한다.
- 초기화 작업이 필요: 이더넷의 송∙수신 동작을 제어하는 MAC이라는 회로에 MAC주소를 설정

  구조
  - 버퍼 메모리 : 송수신 패킷을 일시적으로 저장하는 메모리
  - ROM : MAC 주소를 기입하는 부분 (전 세계적으로 중복되지 않도록 일원화해서 관리 제조시 기록)
  - MAC : 충돌 검출/ 다시 송신 등 이더넷의 송수신 동작을 제어하는 부분
  - PHY(MAU) : 송수신 회로를 합쳐 부르는 말
  - RJ-45 커넥터 : LAN 케이블의 접속부

![LAN 어댑터](https://jayyhkwon.github.io/assets/post-img/network/LANAdapter.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}
  

## 8. 패킷에 3개 제어용 데이터를 추가한다 ##
- LAN 드라이버는 IP 담당 부분에서 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리에 복사 -> 패킷을 송신하도록 MAC 회로에 명령을 보낸다
-> MAC 회로도 TCP, IP가 그랬듯이 패킷에 새로운 부분을 추가한다.

![LAN 어댑터에서 만드는 데이터 구조](https://jayyhkwon.github.io/assets/post-img/network/packetFromLAN.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

- 맨 앞에 프리앰블과 스타트 프레임 딜리미터라는 데이터, 맨 뒤에 프레임 체크 시퀀스라는 오류 검출용 데이터를 추가한다. * 여기서 프레임은 패킷과 동의어다. ( 이더넷 표준 사양에서 사용하는 용어이다. )

![프리앰블과 스타트 프레임 딜리미터](https://jayyhkwon.github.io/assets/post-img/network/preamble.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

- 프리앰블(preamble)
  - 송신하는 패킷을 읽을 때 타이밍을 잡기 위한 것으로, '101010...' 같이 1과 0이 번갈아 나타나는 56비트의 데이터. 이 신호를 이용해서, 1과 0 사이의 간격을 알아낸다. (클록 신호의 타이밍을 잡기 위한 특별한 신호)

- 스타트 프레임 딜리미터
  - 프리앰블이 끝나는 시점에 이어지는 11의 값으로, 패킷이 시작되는 위치를 파악한다.

![Clock 신호 merge 방법](https://jayyhkwon.github.io/assets/post-img/network/timingByClock.jpeg){: #magnific title="https://jayyhkwon.github.io/network/2019/12/17/Network-IP-%EC%9D%B4%EB%8D%94%EB%84%B7-%EC%86%A1%EC%88%98%EC%8B%A0%EA%B3%BC%EC%A0%95(1)/"}

- 클록 신호 
  - 디지털 데이터를 전기 신호로 나타낼 때는 0과 1의 비트 값을 전압이나 전류의 값에 대응시킨다. 그러나 0과 1이 이어지면 신호의 변화가 없어져서 비트 구분을 할 수 없게 된다는 문제가 생긴다. 이 문제를 해결하기 위한 방법은 <b>데이터를 나타내는 신호와 비트 구분을 나타내는 클록이라는 신호를 보내는 방법</b>이다. 

- 프레임 체크 시퀀스(FCS)
  - 패킷을 운반하는 도중 잡음 등의 영향으로 파형이 흐트러지는 등의 오류를 검출하기 위한 비트열 (32비트) 패킷의 앞 부분부터 끝까지 어떠한 계산식에 의해 계산된 값을 넣어둔다.

## 9. 허브를 향해 패킷을 송신한다 ##
- MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 전기 신호로 변환하고, 이것을 PHY 또는 MAU라는 송∙수신 신호부분에 보낸다.
- 그리고 PHY(MAU)회로에서 실제로 케이블에 송출하는 형식(케이블의 종류나 전송 속도에 따라 몇 가지 신호형식이 규정)으로 변환하여 송신한다. PHY(MAU)회로는 <b>MAC 회로가 송신한 신호의 형식을 변환</b>하기 위한 변환회로이다.

- 반이중 모드 (리피터 허브)

  - 케이블에 다른 송신 동작이 흐르고 있으면 대기했다가 송신 동작을 시작한다.
  - 송수신 신호가 동시에 흐르면 충돌이 나며 재밍 신호를 보내고 송신 동작을 멈추고 대기시간을 2배로 늘린다 (10번 반복시 오류처리).

- 전이중 모드(스위치 허브)는 충돌이 일어나지 않는다. 

## 10. 돌아온 패킷을 받는다 ##

수신 동작은 수신 신호선에서 신호를 받아들이는 것부터 시작

1. 프리앰블을 이용하여 타이밍 계산
2. 스타트 프레임 딜리미터 후 부터 디지털 데이터로 변환하여 동작을 개시
3. PHY회로에서 MAC 회로로 보낸다
4. MAC회로에서 FCS 값을 검사한다. - 오류시 폐기
5. MAC 헤더의 수신처 MAC 주소를 조사 - 자신의 것이 아닐시 폐기 (리퍼티 허브)
6. 본체에 통지
  - 인터럽트라는 구조를 사용
    - 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 LAN 어댑터쪽에 주의시키는 것
    - LAN 드라이버가 LAN 어댑터의 버퍼 메모리에서 수신한 패킷 추출
7. MAC 헤더의 프로토콜 판별
8. 프로토콜에 맞는 프로토콜 스택에 건네준다


## 11. 서버의 응답 패킷을 IP 에서 TCP로 넘긴다 ##

웹서버에서 패킷이 돌아온 것으로 간주하고 프로토콜 스택의 동작을 추적해보자. LAN 드라이버는 tcp/ip 의 프로토콜 스택에 패킷을 건넨다

- IP 담당 부분은 IP 헤더 부분을 조사하여 포멧에 문제가 없는지 확인하고 수신처의 IP 주소를 조사하여 자신의 IP 주소와 동일시 TCP 담당부분에 건네준다
  - IP가 다른 경우 IP 담당 부분이 ICMP라는 메시지를 사용하여 통신상대에게 오류를 통지
  - IP 헤더에는 플래그라는 항목이 있는데 이를 통해서 IP 프로토콜의 조각 나누기 기능이 실행되었는지 확인할 수 있다.
    - 이는 패킷을 분할하여 보내는 것을 의미하는데, 이 경우에는 IP 담당 부분 내부에서 일시적으로 데이터를 보관하여 IP 헤더의 ID를 확인해 ID 정보가 같은 값들을 참조하게 한다.
  - 리어셈블링
    - 패킷을 원래의 모습으로 조립하는 동작 (프래그먼트 오프셋을 사용하여 패킷의 순서도 맞춘다)

- TCP 담당 부분은 IP 헤더에 기록된 수신처 IP, 송신처 IP, TCP 헤더에 기록된 수신처 포트 번호, 송신처 포트 번호를 조사해 해당하는 소켓을 찾아낸다. (TCP에서 IP 헤더를 읽는 것은 역할을 침해하는 것이긴 하지만, 속도를 위해서 허용)
  - 소켓은 다시 적절한 동작을 하여, 애플리케이션에게 데이터를 주거나, 접속, 연결 끊기 등 동작을 실행한다.


# 6. UDP 프로토콜을 이용한 송수신 동작 #
- 수정 송신이 필요 없는 데이터의 송신은 UDP가 효율적이다
  - 데이터를 송수신하기 전에 제어 정보를 주고 받을 필요도 없고, 접속이나 연결 끊기 단계도 없으며, 애플리케이션에서 송신 데이터를 받으면 UDP 헤더만 추가하여 IP에 바로 의뢰한다.
  - 수신할 때도 간단한데, IP 헤더의 수신처, 송신처 IP와 UDP 헤더에 있는 수신처, 송신처 포트 번호를 소켓 정보와 결합해 데이터를 건네줄 애플리케이션을 바로 특정해낸다.
  
![tcp-udp](https://user-images.githubusercontent.com/46305139/96718424-f93d1a80-13e2-11eb-9cf5-b3499edf986f.png){: #magnific title="https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4"}

![tcp-udp-img](https://user-images.githubusercontent.com/46305139/96718812-82ece800-13e3-11eb-97ca-113736e13b4c.png){: #magnific title="https://juni5184.tistory.com/10"}

- 제어용 짧은 데이터
  - DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많다
  - 만약 오류 발생시 응답이 돌아오지 않으므로 어플리케이션이 다시 데이터를 요청하면 된다

- 음성 및 동영상 데이터
  - 음성이나 영상 데이터는 결정된 시간안에 데이터를 건네주어야 한다
  - TCP의 경우 시간이 더 걸리므로 재생 타이밍이 맞지 않을 수 있다.